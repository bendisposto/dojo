[
  {
    name: "Happy Numbers Kata",
    description: "<html><head><meta charset='utf-8'></head><body><h1>Happy Numbers</h1><p> Wir wollen uns eine einfache Rechenvorschrift anschauen, die wir auf eine positive Zahl anwenden wollen: <ul><li>Die Zahl wird in ihre Ziffern zerlegt (z.B. die Zahl 4711 in 4,7,1,1)</li><li>Die Ziffern werden quadriert (in unserem Bsp. 16,49,1,1)</li><li>Die Quadrate werden summiert (also 16 + 49 + 1 + 1 = 67)</li> </ul>Interessanterweise gibt es nur zwei mögliche Szenarien, wenn man diese Vorschrift immer wieder auf das Resultat anwendet.<ul><li>Entweder das Ergebnis wird 1</li><li>oder wir kommen in einen Zyklus aus folgenden 8 Zahlen: 4,16,37,58,89,145,42,20</li> </ul>Zahlen, die bei 1 enden, nennt man Happy Numbers. </p></body></html>",
    code: {
      name: "Happy",
      code: [
        "public class Happy {",
        "    ",
        "    public static int happyStep(int n) {",
        "        return -1;",
        "    }",
        "",
        "    public static boolean isHappy(int n) {",
        "        return false;",
        "    }",
        "",
        "    /**",
        "     * Zerlegt n in Ziffern. Die einzelnen Ziffern werden in einem Array",
        "     * gespeichert. Die Ziffern sind nicht in korrekter Reihenfolge, das spielt",
        "     * hier aber keine Rolle, da sowieso summiert wird.",
        "     * ",
        "     * @param Zahl,",
        "     *            die zerlegt werden soll",
        "     * @return Array der Ziffern der Eingabezahl",
        "     */",
        "    public static int[] digits(int n) {",
        "        int size = String.valueOf(n).length(); // Arraylaenge bestimmen",
        "        int[] result = new int[size];",
        "        for (int j = 0; j < result.length; j = j + 1, n = n / 10) {",
        "            result[j] = n % 10;",
        "        }",
        "        return result;",
        "    }",
        "",
        "}"
      ]
    },
    test: {
      name: "HappyTest",
      code: [
        "import static org.junit.Assert.*;",
        "import org.junit.*;",
        "",
        "public class HappyTest {",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnOne_ifCalledWithOne() {",
        "        assertEquals(1, Happy.happyStep(1));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnFour_ifCalledWithTwo() {",
        "        assertEquals(4, Happy.happyStep(2));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnNine_ifCalledWithThree() {",
        "        assertEquals(9, Happy.happyStep(3));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnFive_ifCalledWithTwelve() {",
        "        assertEquals(5, Happy.happyStep(12));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnOne_ifCalledWithTen() {",
        "        assertEquals(1, Happy.happyStep(10));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnTwentyOne_ifCalledWithFourHundredTwentyOne() {",
        "        assertEquals(21, Happy.happyStep(421));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void happyStep_shouldReturnNintyOne_ifCalledWith123456() {",
        "        assertEquals(91, Happy.happyStep(123456));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void oneIsHappy() {",
        "        assertEquals(true, Happy.isHappy(1));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void fourIsNotHappy() {",
        "        assertEquals(false, Happy.isHappy(4));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void fiveIsNotHappy() {",
        "        assertEquals(false, Happy.isHappy(5));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void sevenIsHappy() {",
        "        assertEquals(true, Happy.isHappy(7));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void nineIsNotHappy() {",
        "        assertEquals(false, Happy.isHappy(9));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void tenIsHappy() {",
        "        assertEquals(true, Happy.isHappy(10));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void elevenIsHappy() {",
        "        assertEquals(false, Happy.isHappy(11));",
        "    }",
        "",
        "    @Test",
        "    public void digits_shouldReturnASingletonArray_ifCalledWithASingleDigit() {",
        "        assertArrayEquals(new int[] { 4 }, Happy.digits(4));",
        "    }",
        "",
        "    @Test",
        "    public void digits_shouldReturnAnArrayOfSizeTwo_ifCalledWithATwoDigitNumber() {",
        "        assertArrayEquals(new int[] { 2, 4 }, Happy.digits(42));",
        "    }",
        "",
        "    @Test",
        "    public void digits_shouldReturnAnArrayOfSizeFour_ifCalledWithAFourDigitNumber() {",
        "        assertArrayEquals(new int[] { 1, 1, 7, 4 }, Happy.digits(4711));",
        "    }",
        "",
        "}"
      ]
    },
    babyStepsActivated: false,
    retrospective: false
  },
  {
    name: "Game of Life Kata",
    description: "<html><head><meta charset='utf-8'></head><body><h1>Game of Life</h1><p>Game of life ist ein sogenannter zellullärer Automat. Wir haben ein Spielfeld, das aus Zellen besteht. Eine Zelle kann entweder tot sein oder leben. Jede Zelle hat acht Nachbarzellen. Die Randzellen werden als grundsätzlich tot definiert.</p><p>Es gibt drei Regeln, die über Leben und Tod entscheiden:<ol><li> Eine lebende Zelle, die weniger als zwei lebende Nachbarzellen hat, stirbt an Einsamkeit.</li><li> Eine lebende Zelle, die mehr als drei lebende Nachbarzellen hat, stirbt an Überpopulation.</li><li>Eine tote Zelle, die genau drei lebende Nachbarzellen hat, wird lebendig.</li></ol><br>Eine vierte Regel folgt aus den anderen drei Regeln: Eine lebende Zelle mit 2 oder 3 lebenden Nachbarzellen überlebt, eine tote Zelle mit mehr oder weniger als drei lebenden Nachbarn bleibt tot.</p><img width='50%' src='https://bendisposto.github.io/dojo/gol/gol.png'></body></html>",
    code: {
      name: "GameOfLife",
      code: [
        "public class GameOfLife {",
        "    /*",
        "     * Gibt 0 zurueck, falls die Zelle in der naechsten Generation tot sein soll",
        "     * Gibt 1 zurueck, falls die Zelle in der naechsten Generation lebendig sein soll",
        "     */",
        "    public static int spielregel(int nachbarn, int aktiv) {",
        "        return -1;",
        "    }",
        "",
        "    /*",
        "     * Gibt die Anzahl der Nachbarn der Zelle an Position zeile, spalte in dem",
        "     * Array board zurueck.",
        "     */",
        "    public static int zaehleLebendeNachbarn(int[][] board, int zeile, int spalte) {",
        "        return -1;",
        "    }",
        "",
        "",
        "    /* Ausgehend von dem Array board wird ein Schritt berechnet.",
        "     * Hinweis: Alle Randzellen sind immer 0",
        "     */",
        "    public static int[][] berechneNaechsteGeneration(int[][] board) {",
        "        return board;",
        "    }",
        "}"
      ]
    },
    test: {
      name: "GameOfLifeTest",
      code: [
        "import static org.junit.Assert.*;",
        "import org.junit.*;",
        "",
        "public class GameOfLifeTest {",
        "",
        "    @Ignore",
        "    @Test",
        "    public void einsameZellenSterbenKeineNachbarn() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(0, 1));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void toteZellenMitDreiNachbarnWerdenLebendig() throws Exception {",
        "        assertEquals(1, GameOfLife.spielregel(3, 0));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void lebendeZellenMitZweiNachbarnBleibenLebendig() throws Exception {",
        "        assertEquals(1, GameOfLife.spielregel(2, 1));",
        "    }",
        "    @Ignore",
        "    @Test",
        "    public void toteZellenMitZweiNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(2, 0));",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void toteZellenOhneNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(0, 0));",
        "    }",
        "",
        " // Folgende Tests sind zur Sicherheit, sie sollten nun alle laufen.",
        " // Entfernen Sie den Blockkommentar und pruefen Sie ob alles laeuft.",
        "",
        "/* ",
        "",
        "    @Test",
        "    public void einsameZellenSterbenEinNachbar() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(1, 1));",
        "    }",
        "",
        "    @Test",
        "    public void zellenMitVierNachbarnSterben() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(4, 1));",
        "    }",
        "",
        "    @Test",
        "    public void zellenMitFuenfNachbarnSterben() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(5, 1));",
        "    }",
        "",
        "    @Test",
        "    public void zellenMitSechsNachbarnSterben() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(6, 1));",
        "    }",
        "",
        "    @Test",
        "    public void zellenMitSiebenNachbarnSterben() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(7, 1));",
        "    }",
        "",
        "    @Test",
        "    public void zellenMitAchtNachbarnSterben() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(8, 1));",
        "    }",
        "",
        "    @Test",
        "    public void toteZellenMitEinemNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(1, 0));",
        "    }",
        "",
        "",
        "    @Test",
        "    public void lebendeZellenMitDreiNachbarnBleibenLebendig() throws Exception {",
        "        assertEquals(1, GameOfLife.spielregel(3, 1));",
        "    }",
        "",
        "    @Test",
        "    public void toteZellenMitVierNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(4, 0));",
        "    }",
        "",
        "    @Test",
        "    public void toteZellenMitFuenfNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(5, 0));",
        "    }",
        "",
        "    @Test",
        "    public void toteZellenMitSechsNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(6, 0));",
        "    }",
        "",
        "    @Test",
        "    public void toteZellenMitSiebenNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(7, 0));",
        "    } ",
        "",
        "    @Test",
        "    public void toteZellenMitAchtNachbarnBleibenTot() throws Exception {",
        "        assertEquals(0, GameOfLife.spielregel(8, 0));",
        "    }     ",
        " */",
        "",
        "    @Ignore",
        "    @Test",
        "    public void keineNachbarn() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 0, 0, 0, 0 },",
        "                    { 0, 0, 0, 0 },",
        "                    { 0, 0, 0, 1 }},",
        "                     1,1); /* 2. Zeile, 2. Spalte */",
        "        assertEquals(0, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void einNachbar() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 0, 0, 0, 0 },",
        "                    { 0, 0, 0, 0 },",
        "                    { 0, 0, 0, 1 }}, 1, 2); /* 2. Zeile, 3. Spalte */",
        "        assertEquals(1, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void einNachbarUndEineEntfernteZelle() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 1, 0, 0, 0 },",
        "                    { 0, 0, 0, 0 },",
        "                    { 0, 0, 0, 1 } }, 1, 2); ",
        "        assertEquals(1, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void vierNachbarnEinerInaktivenZelle() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 1, 0, 1, 0 },",
        "                    { 0, 0, 0, 1 },",
        "                    { 0, 1, 0, 1 }}, 1, 2);",
        "        assertEquals(4, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void vierNachbarnEinerAktivenZelle() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 1, 0, 1, 0 },",
        "                    { 0, 0, 1, 1 },",
        "                    { 0, 1, 0, 1 }}, 1, 2);",
        "        assertEquals(4, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void achtNachbarnEinerAktivenZelle() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 1, 1, 1, 1 },",
        "                    { 0, 1, 1, 1 },",
        "                    { 0, 1, 1, 1 }}, 1, 2);",
        "        assertEquals(8, lebendeNachbarn);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void achtNachbarnEinerInaktivenZelle() {",
        "        int lebendeNachbarn = GameOfLife",
        "                .zaehleLebendeNachbarn(new int[][] {",
        "                    { 1, 1, 1, 1 },",
        "                    { 0, 1, 0, 1 },",
        "                    { 0, 1, 1, 1 }}, 1, 2);",
        "        assertEquals(8, lebendeNachbarn);",
        "    }",
        "",
        "    /* Randzellen sind immer tot! */",
        "",
        "    @Ignore",
        "    @Test",
        "    public void simpleGen1() throws Exception {",
        "        int[][] input = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 1, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        int[][] output = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        checkBoard(GameOfLife.berechneNaechsteGeneration(input), output);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void simpleGen2() throws Exception {",
        "        int[][] input = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 1, 1, 0, 0 },",
        "            { 0, 1, 1, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        int[][] output = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 1, 1, 0, 0 },",
        "            { 0, 1, 1, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        checkBoard(GameOfLife.berechneNaechsteGeneration(input), output);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void simpleGen3() throws Exception {",
        "        int[][] input = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 1, 0, 0 },",
        "            { 0, 0, 0, 1, 0 },",
        "            { 0, 1, 1, 1, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        int[][] output = {",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 0, 0, 0, 0 },",
        "            { 0, 1, 0, 1, 0 },",
        "            { 0, 0, 1, 1, 0 },",
        "            { 0, 0, 0, 0, 0 }};",
        "        checkBoard(GameOfLife.berechneNaechsteGeneration(input), output);",
        "    }",
        "",
        "    @Ignore",
        "    @Test",
        "    public void simpleGen4() throws Exception {",
        "        int[][] input = {",
        "            { 0, 0, 0, 0, 0, 0 },",
        "            { 0, 0, 1, 1, 0, 0 },",
        "            { 0, 0, 0, 1, 1, 0 },",
        "            { 0, 1, 1, 1, 0, 0 },",
        "            { 0, 0, 0, 0, 0, 0 }};",
        "        int[][] output = {",
        "            { 0, 0, 0, 0, 0, 0 },",
        "            { 0, 0, 1, 1, 1, 0 },",
        "            { 0, 1, 0, 0, 1, 0 },",
        "            { 0, 0, 1, 1, 1, 0 },",
        "            { 0, 0, 0, 0, 0, 0 }};",
        "        checkBoard(GameOfLife.berechneNaechsteGeneration(input), output);",
        "    }",
        "",
        "",
        "    private void checkBoard(int[][] output, int[][] input) {",
        "        assertEquals(input.length, output.length);",
        "        for (int i = 0; i < output.length; i++) {",
        "            assertArrayEquals(output[i], input[i]);",
        "        }",
        "    }",
        "",
        "}"
      ]
    },
    babyStepsActivated: false,
    retrospective: false
  },
  {
    name: "Römische Zahlen Ping Pong",
    description: "<html><head><meta charset='utf-8'></head><body><h1>Römische Zahlen</h1><h2>Achtung: Heute werden wir eine Ping Pong Kata machen.</h2><ol><li>Sie schreiben einen fehlschlagenden Test.</li><li>Sie geben die Tastaur an ihre(n) Partner(in) weiter.</li><li>Ihr(e) Partner(in) schreibt nun Code, der die Tests erfüllt.</li><li>Sie überlegen gemeinsam, ob ein Refactoring Sinn ergibt und Ihr(e) Partner(in) führt das Refactoring aus.</li><li>Der Prozess beginnt von vorne mit vertauschten Rollen, d.h., Ihr(e) Partner(in) schreibt nun einen Test und dann wird gewechselt.</li></ol><p>Die Methode <code>convert</code> soll implementiert werden. Sie bekommt eine ganze Zahl zwischen 1 und 50 übergeben und gibt die Darstellung der Zahl im römischen Zahlensystem aus. Für ungültige Eingaben soll der leere String zurückgegeben werden.</p><p>Die Zahlzeichen des römischen Ziffersystems sind: I (1), V (5) X (10) und 50 (L). Es werden höchstens drei gleiche Ziffern hintereinander geschreiben, dann greift die Subtraktionsregel, d.h. Es kann ein einzelnes I vor ein V oder ein  X, bzw. ein einzelnes X vor ein L geschrieben werden. Die Subraktionsregel liefert also zum Beispiel die Zahlen 4 (IV), 9 (IX), 40 (XL).</p><p>Einige weitere Beispiele: 14  = 10 + 4 (XIV), 39 = 30 + 9 (XXXIX), 44 = 40 + 4 (XLIV).</p></body></html>",
    code: {
      name: "RomanNumbers",
      code: [
        "public class RomanNumbers {",
        "    ",
        "    public static String convert(int n) {",
        "        return \"I am groot.\";",
        "    }",
        "",
        "}"
      ]
    },
    test: {
      name: "RomanNumbersTest",
      code: [
        "import static org.junit.Assert.*;",
        "import org.junit.*;",
        "",
        "public class RomanNumbersTest {",
        "",
        "    @Test",
        "    public void oneIsI() {",
        "        assertEquals(1, 1); // Replace me",
        "    }",
        "",
        "}"
      ]
    },
    babyStepsActivated: false,
    retrospective: false
  },
  {
    name: "Stirb langsam",
    description: "<html><head><meta charset='utf-8'><style> thead th { text-align: left; } td, th { border: 1px solid #ddd; padding: 0.5em; } table { border-collapse: collapse; } </style></head><body><h1>Die Hard Sale</h1><p>Ein Online Händler möchte die &quot;Stirb langsam&quot; Blu-Rays Discs (BD) promoten und bewirbt daher eine Rabatt-Aktion. Der Grundpreis für jede BD beträgt 8 Euro. Wenn man aber zwei verschiedene Teile der Reihe kauft, bekommt man einen Rabatt von 5% auf den Preis der beiden BDs. Kauft man drei verschiedene Teile bekommt man einen Rabatt von 10%, bei vier Teilen 20% und wenn man alle fünf Teile kauft bekommt man einen Rabatt von 25%. Der Preis wird auf ganze Cents abgerundet.</p><p>Für die Rabatte ist es wichtig, dass es immer verschiedene Teile sind!</p><p>Beispiele:</p><table><thead><tr><th>Warenkorb</th><th>Preis (€)</th><td></td></tr></thead><tbody><tr><td>2 x Teil 1</td><td>16,00</td><td>Kein Rabatt, da es der gleiche Teil ist</td></tr><tr><td>Teil 1 + Teil 2</td><td>15,20</td><td></td></tr><tr><td>2 x Teil 1 + Teil 2 </td><td>23,20 </td><td>Es gibt Rabatt auf Teil 1 + Teil 2, aber nicht auf die zweite BD von Teil 1</td></tr><tr><td>2 x Teil 1 + 2 x Teil 2</td><td>30,40</td><td>Es gibt 2 Mal Rabatt auf die beiden Teile (aber keinen 20% Rabatt auf vier BDs)</td></tr><tr><td>Teil 1, 2, 3 und 4</td><td>25,60</td><td>20% Rabatt auf die vier BDs </td></tr></tbody></table><p>Dieses Kata ist bekannter unter dem Namen Potter Kata, da es entstand, als es 5 Harry Potter Bücher gab.</p><h3>Vorgehensweise</h3><p>Gehen Sie kleinschrittig an die Aufgabe heran und schreiben Sie sinnvolle Tests. Dieses Kata ist sehr anspruchsvoll, aber in kleinen Schritten kommt man gut voran.</p><h4>Ideen für Tests</h4><ol><li>Eine Blu-Ray egal welchen Teils bekommt keinen Rabatt</li><li>Mehrere BDs desselben Teils bekommen keinen Rabatt</li><li>2 / 3 / 4 / 5 verschiedene BDs bekommen Rabatt</li><li>Kombination von Rabatten</li><li>Randfälle</li></ol></body></html>",
    code: {
      name: "DieHardRabatt",
      code: [
        "public class DieHardRabatt {",
        "    ",
        "    public static double summe(int[] warenkorb) {",
        "        return -3;",
        "    }",
        "",
        "}"
      ]
    },
    test: {
      name: "DieHardRabattTest",
      code: [
        "import static org.junit.Assert.*;",
        "import org.junit.*;",
        "",
        "public class DieHardRabattTest {",
        "",
        "",
        "    @Test",
        "    public void keineTeileKostenNichts() {",
        "        int[] warenkorb = {0,0,0,0,0};",
        "        assertEquals(0.0, DieHardRabatt.summe(warenkorb) , 0.01);",
        "    }",
        "",
        "}"
      ]
    },
    babyStepsActivated: true,
    retrospective: false
  }
]
